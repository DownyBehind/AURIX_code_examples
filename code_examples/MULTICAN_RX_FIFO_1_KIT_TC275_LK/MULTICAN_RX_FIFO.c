/********************************************************************************************************************
 * \file MULTICAN_RX_FIFO.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "MULTICAN_RX_FIFO.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
AppMulticanType             g_multican;
IfxPort_Pin_Config          g_led1;
CanCommunicationStatusType  g_status = CanCommunicationStatus_Success;
const uint32                g_canInitialMessageData[2] = {0xDA7A0000, 0xBA5E0000};  /* Dummy values */

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro:
 * - defines linker section as .intvec_tc<vector number>_<interrupt priority>.
 * - defines compiler specific attribute for the interrupt functions.
 * - defines the Interrupt service routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of Interrupt Macro for more details.
 */
/* NOTE: the vector table number parameter (vectabNum) must match the CPU index that is servicing the ISR */
IFX_INTERRUPT(canIsrOverflowHandler, 1, ISR_PRIORITY_CAN_OVERFLOW);

/* Interrupt Service Routine (ISR) called once the RX interrupt has been generated.
 * Reads the received CAN message and, in case of no errors, increments the counter
 * to indicate the number of successfully received CAN messages.
 */
void canIsrOverflowHandler(void)
{
    IfxMultican_Status readStatus;
    uint8 currentCanMessage;
    static volatile uint8 numOfReceivedMessages = 0; /* Static needed to hold the value through different ISR calls */

    for(currentCanMessage = 0; currentCanMessage < RX_FIFO_SIZE; currentCanMessage++)
    {
        /* Read the received CAN message and store the status of the operation */
        readStatus = IfxMultican_Can_MsgObj_readMessage(&g_multican.canDstMsgObj, &g_multican.rxMsg[numOfReceivedMessages]);

        /* If no new data has been received, report an error */
        if(readStatus != IfxMultican_Status_newData)
        {
            g_status = CanCommunicationStatus_Error_noNewDataReceived;
        }

        /* If a new data has been received but one message was lost, report an error */
        if(readStatus == IfxMultican_Status_newDataButOneLost)
        {
            g_status = CanCommunicationStatus_Error_newDataButOneLost;
        }

        /* If there was no error, increment the counter to indicate the number of successfully received CAN messages */
        if (g_status == CanCommunicationStatus_Success)
        {
            numOfReceivedMessages++;

            if(numOfReceivedMessages == NUMBER_OF_RECEIVED_MESSAGES)
            {
                g_allMessagesReceived = TRUE;
            }
        }
    }
}

/* Function to initialize the MULTICAN module, nodes and message objects related for this application use case */
void initMultican(void)
{
    Ifx_CAN_MO *hwObj;

    /* ==========================================================================================
     * CAN module configuration and initialization:
     * ==========================================================================================
     *  - load default CAN module configuration into configuration structure
     *  - define the interrupt priority for interrupt node pointer used in the example
     *  - define the interrupt service provider that should handle the interrupt service request
     *  - initialize CAN module with the modified configuration
     * ==========================================================================================
     */
    IfxMultican_Can_initModuleConfig(&g_multican.canConfig, &MODULE_CAN);

    g_multican.canConfig.nodePointer[OVERFLOW_INTERRUPT_SRC_ID].priority = ISR_PRIORITY_CAN_OVERFLOW;
    g_multican.canConfig.nodePointer[OVERFLOW_INTERRUPT_SRC_ID].typeOfService = ISR_PROVIDER_CAN_OVERFLOW;

    IfxMultican_Can_initModule(&g_multican.can, &g_multican.canConfig);

    /* ==========================================================================================
     * Common CAN node configuration and initialization:
     * ==========================================================================================
     *  - load default CAN node configuration into configuration structure
     *  - set CAN node in the "Loop back" mode (no external pins are used)
     * ==========================================================================================
     */
    IfxMultican_Can_Node_initConfig(&g_multican.canNodeConfig, &g_multican.can);

    g_multican.canNodeConfig.loopBackMode = TRUE;

    /* ==========================================================================================
     * CAN node 0 configuration and initialization:
     * ==========================================================================================
     *  - assign node to CAN node 0
     *  - initialize the CAN node 0 with the modified configuration
     * ==========================================================================================
     */
    g_multican.canNodeConfig.nodeId = IfxMultican_NodeId_0;

    IfxMultican_Can_Node_init(&g_multican.canNode0, &g_multican.canNodeConfig);

    /* ==========================================================================================
     * CAN node 1 configuration and initialization:
     * ==========================================================================================
     *  - assign node to CAN node 1
     *  - initialize the CAN node 1 with the modified configuration
     * ==========================================================================================
     */
    g_multican.canNodeConfig.nodeId = IfxMultican_NodeId_1;

    IfxMultican_Can_Node_init(&g_multican.canNode1, &g_multican.canNodeConfig);

    /* =======================================================================================================
     * Source standard message object configuration and initialization:
     * =======================================================================================================
     *  - load default CAN message object configuration into configuration structure
     *
     *  - define the message object ID (each message object ID value should be unique)
     *  - define the CAN message ID used during arbitration phase (same as ID used for RX FIFO base object)
     *  - define the message object as a transmit message object
     *
     *  - initialize the source standard CAN message object with the modified configuration
     * -------------------------------------------------------------------------------------------------------
     * This CAN message object is assigned to CAN Node 0
     * =======================================================================================================
     */
    IfxMultican_Can_MsgObj_initConfig(&g_multican.canMsgObjConfig, &g_multican.canNode0);

    g_multican.canMsgObjConfig.msgObjId = SRC_MESSAGE_OBJECT_ID;
    g_multican.canMsgObjConfig.messageId = CAN_MESSAGE_ID;
    g_multican.canMsgObjConfig.frame = IfxMultican_Frame_transmit;

    IfxMultican_Can_MsgObj_init(&g_multican.canSrcMsgObj, &g_multican.canMsgObjConfig);

    /* =======================================================================================================
     * RX FIFO structure configuration and initialization:
     * =======================================================================================================
     *  - load default CAN message object configuration into configuration structure
     *
     *  - define the message object ID (each message object ID value should be unique)
     *  - define the CAN message ID used during arbitration phase (same as ID used for transmit message object)
     *  - define the size of the structure (more than 1 message object specifies FIFO structure)
     *  - define the message object as a receive message object (RX FIFO in this case)
     *  - define the first slave object ID as the next message object after RX FIFO base object
     *
     *  - initialize the CAN message objects with the modified configuration
     *
     *  - get the pointer of the RX FIFO base object
     *  - enable overflow interrupt generation
     *  - in case of RX FIFO base object, transmit interrupt node becomes active once overflow event occurs
     *  - place SET pointer at the first slave message object (once the whole RX FIFO buffer is filled,
     *    the overflow interrupt will be triggered)
     * -------------------------------------------------------------------------------------------------------
     * This CAN message object is assigned to CAN Node 1
     * =======================================================================================================
     */
    IfxMultican_Can_MsgObj_initConfig(&g_multican.canMsgObjConfig, &g_multican.canNode1);

    g_multican.canMsgObjConfig.msgObjId = RX_FIFO_BASE_OBJECT_ID;
    g_multican.canMsgObjConfig.messageId = CAN_MESSAGE_ID;
    g_multican.canMsgObjConfig.msgObjCount = RX_FIFO_SIZE;
    g_multican.canMsgObjConfig.frame = IfxMultican_Frame_receive;
    g_multican.canMsgObjConfig.firstSlaveObjId = SLAVE_MESSAGE_OBJECT_ID;

    IfxMultican_Can_MsgObj_init(&g_multican.canDstMsgObj, &g_multican.canMsgObjConfig);

    hwObj = IfxMultican_MsgObj_getPointer(g_multican.can.mcan, RX_FIFO_BASE_OBJECT_ID);
    IfxMultican_MsgObj_setOverflowInterrupt(hwObj, TRUE);
    IfxMultican_MsgObj_setTransmitInterruptNodePointer(hwObj, OVERFLOW_INTERRUPT_SRC_ID);
    IfxMultican_MsgObj_setSelectObjectPointer(hwObj, SLAVE_MESSAGE_OBJECT_ID);
}

/* Function to initialize and transmit CAN messages.
 * Before a CAN message is transmitted, a number of CAN messages need to be initialized.
 * The user can change the number of CAN messages by modifying NUMBER_OF_CAN_MESSAGES macro value.
 * The TX messages (messages that are transmitted) are initialized with the combination of predefined
 * content and current CAN message value. The RX messages (messages where the received CAN data is stored)
 * are initialized with invalid ID, data and length value. After successful CAN transmission, the values are
 * replaced with the valid content.
 */
void transmitCanMessages(void)
{
    uint8 currentCanMessage;

    /* Invalidation of the RX messages */
    for(currentCanMessage = 0; currentCanMessage < NUMBER_OF_CAN_MESSAGES; currentCanMessage++)
    {
        IfxMultican_Message_init(&g_multican.rxMsg[currentCanMessage],
                                 INVALID_ID_VALUE,
                                 INVALID_DATA_VALUE,
                                 INVALID_DATA_VALUE,
                                 INVALID_LENGTH_VALUE);
    }

    for(currentCanMessage = 0; currentCanMessage < NUMBER_OF_CAN_MESSAGES; currentCanMessage++)
    {
        /* Initialization of the TX message */
        IfxMultican_Message_init(&g_multican.txMsg,
                                 CAN_MESSAGE_ID,
                                 (g_canInitialMessageData[0] | currentCanMessage),
                                 (g_canInitialMessageData[1] | currentCanMessage),
                                 g_multican.canMsgObjConfig.control.messageLen);

        /* Send the CAN message with the previously defined TX message content */
        while(IfxMultican_Status_notSentBusy ==
           IfxMultican_Can_MsgObj_sendMessage(&g_multican.canSrcMsgObj, &g_multican.txMsg))
        {
        }
    }
}

/* Function to verify CAN messages.
 * After all the expected messages have been received by the RX FIFO, several checks are performed.
 *     - message ID check
 *     - message length check
 *     - data check (expected valid data and unchanged invalid data)
 */
void verifyCanMessages(void)
{
    uint8 currentCanMessage;

    /* Verification of the CAN messages is done in two steps while there are two ranges that need to be checked.
     *     - First "for" loop compares the valid expected data to the received data for the CAN messages in the
     *       [0, NUMBER_OF_RECEIVED_MESSAGES] range. NUMBER_OF_RECEIVED_MESSAGES defines the expected number of
     *       received CAN messages by the RX FIFO object that are read by the ISR. This number DOES NOT NEED to
     *       be equal to NUMBER_OF_CAN_MESSAGES (explanation is provided in the accompanying tutorial document).
     *
     *     - Second "for" loop checks the invalid data to make sure that the content has not been changed for the
     *       CAN messages in the [NUMBER_OF_RECEIVED_MESSAGES, NUMBER_OF_CAN_MESSAGES] range. Due to the fact that
     *       both ranges have NUMBER_OF_RECEIVED_MESSAGES in common, the initial value for the second "for" loop is
     *       not initialized.
     *
     * If both verification steps have been successful, LED1 is turned on to indicate correctness of the checks.
     */

    for(currentCanMessage = 0; currentCanMessage < NUMBER_OF_RECEIVED_MESSAGES; currentCanMessage++)
    {
        /* Check if the received message ID does NOT match with the transmitted message ID.
         * If this is the case, an error should be reported.
         */
        if(g_multican.rxMsg[currentCanMessage].id != CAN_MESSAGE_ID)
        {
            g_status = CanCommunicationStatus_Error_notExpectedMessageId;
            break;
        }

        /* Check if the received message length does NOT match with the expected message length.
         * If this is the case, an error should be reported.
         */
        if(g_multican.rxMsg[currentCanMessage].lengthCode != g_multican.canMsgObjConfig.control.messageLen)
        {
            g_status = CanCommunicationStatus_Error_notExpectedLengthCode;
            break;
        }

        /* Finally, check if the received data does NOT match with the transmitted one
         * If this is the case, an error should be reported.
         */
        if((g_multican.rxMsg[currentCanMessage].data[0] != (g_canInitialMessageData[0] | currentCanMessage)) ||
            (g_multican.rxMsg[currentCanMessage].data[1] != (g_canInitialMessageData[1] | currentCanMessage)))
        {
            g_status = CanCommunicationStatus_Error_notExpectedData;
            break;
        }
    }

    for(/*...*/; currentCanMessage < NUMBER_OF_CAN_MESSAGES; currentCanMessage++)
    {
        /* Check if the received message ID does NOT match invalid ID value.
         * If this is the case, an error should be reported.
         */
        if(g_multican.rxMsg[currentCanMessage].id != INVALID_ID_VALUE)
        {
            g_status = CanCommunicationStatus_Error_notExpectedMessageId;
            break;
        }

        /* Check if the received message length does NOT match invalid length value.
         * If this is the case, an error should be reported.
         */
        if(g_multican.rxMsg[currentCanMessage].lengthCode != INVALID_LENGTH_VALUE)
        {
            g_status = CanCommunicationStatus_Error_notExpectedLengthCode;
            break;
        }

        /* Finally, check if a received data does NOT match invalid data value.
         * If this is the case, an error should be reported.
         */
        if((g_multican.rxMsg[currentCanMessage].data[0] != INVALID_DATA_VALUE) ||
            (g_multican.rxMsg[currentCanMessage].data[1] != INVALID_DATA_VALUE))
        {
            g_status = CanCommunicationStatus_Error_notExpectedData;
            break;
        }
    }

    /* If there was no error, turn on the LED1 to indicate correctness of the received messages */
    if(g_status == CanCommunicationStatus_Success)
    {
        IfxPort_setPinLow(g_led1.port, g_led1.pinIndex);
    }
}

/* Function to initialize the port pin connected to the LED */
void initLed(void)
{
    /* ======================================================================
     * Configuration of the port pin connected to the LED:
     * ======================================================================
     *  - define the GPIO port
     *  - define the GPIO pin that is the connected to the LED
     *  - define the general GPIO pin usage (no alternate function used)
     *  - define the pad driver strength
     * ======================================================================
     */
    g_led1.port      = &MODULE_P00;
    g_led1.pinIndex  = PIN5;
    g_led1.mode      = IfxPort_OutputIdx_general;
    g_led1.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;

    /* Initialize the port pin connected to the LED to level "HIGH"; this keeps the LED turned off as default state */
    IfxPort_setPinHigh(g_led1.port, g_led1.pinIndex);

    /* Set the pin input/output mode for the pin connected to the LED */
    IfxPort_setPinModeOutput(g_led1.port, g_led1.pinIndex, IfxPort_OutputMode_pushPull, g_led1.mode);

    /* Set the pad driver mode for the pin connected to the LED */
    IfxPort_setPinPadDriver(g_led1.port, g_led1.pinIndex, g_led1.padDriver);
}
