/********************************************************************************************************************
 * \file MULTICAN_FD.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "MULTICAN_FD.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
multicanType                        g_multican;
canCommunicationStatusType          g_status = CanCommunicationStatus_Success;
IfxPort_Pin_Config                  g_led1;
volatile uint8                      g_isrRxCount = 0; /* Declared as volatile in order not to be removed by compiler */
const uint8                         g_dlcLookUpTable[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 32, 48, 64 };
const canMessageObjectConfigType    g_messageObjectConf[NUMBER_OF_CAN_FD_CASES] =
                                    {
                                        { STANDARD_MESSAGE_ID_1, FALSE, IfxMultican_DataLengthCode_8,  FALSE },
                                        { EXTENDED_MESSAGE_ID_1, TRUE,  IfxMultican_DataLengthCode_8,  TRUE  },
                                        { STANDARD_MESSAGE_ID_2, FALSE, IfxMultican_DataLengthCode_32, FALSE },
                                        { EXTENDED_MESSAGE_ID_2, TRUE,  IfxMultican_DataLengthCode_64, TRUE  }
                                    };

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro:
 * - defines linker section as .intvec_tc<vector number>_<interrupt priority>.
 * - defines compiler specific attribute for the interrupt functions.
 * - defines the Interrupt Service Routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of Interrupt Macro for more details.
 */
IFX_INTERRUPT(canIsrRxHandler, 0, ISR_PRIORITY_CAN_RX);

/* Interrupt Service Routine (ISR) called once the RX interrupt is generated.
 * Reads the received CAN message and in case of no errors, increments the counter to
 * indicate the number of successfully received CAN messages.
 */
void canIsrRxHandler(void)
{
    IfxMultican_Status readStatus;

    if(g_messageObjectConf[g_isrRxCount].messageLen > IfxMultican_DataLengthCode_8)
    {
        /* Read the received long frame CAN message and store the status of the operation */
        readStatus = IfxMultican_MsgObj_readLongFrame(g_multican.canDstMsgObj[g_isrRxCount].node->mcan,
                                                      g_multican.canDstMsgObj[g_isrRxCount].msgObjId,
                                                      &g_multican.rxMsg,
                                                      (uint32*)&g_multican.rxData);
    }
    else
    {
        /* Read the received standard frame CAN message and store the status of the operation */
        readStatus = IfxMultican_Can_MsgObj_readMessage(&g_multican.canDstMsgObj[g_isrRxCount], 
                                                        &g_multican.rxMsg);

        memcpy((void *)(&g_multican.rxData[0]), (void *)(&g_multican.rxMsg.data[0]), IfxMultican_DataLengthCode_8);
    }

    /* If no new data has been received, report an error */
    if(!( readStatus & IfxMultican_Status_newData ))
    {
        g_status = CanCommunicationStatus_Error_noNewDataReceived;
    }

    /* If new data has been received but with one message lost, report an error */
    if(readStatus == IfxMultican_Status_newDataButOneLost)
    {
        g_status = CanCommunicationStatus_Error_newDataButOneLost;
    }

    /* If there was no error, increment the counter to indicate the number of successfully received CAN messages */
    if (g_status == CanCommunicationStatus_Success)
    {
        g_isrRxCount++;
    }
}

/* Function to initialize MULTICAN module, nodes and message objects related to this application use case */
void initMultican(void)
{
    uint8 currentCanMessageObject;

    /* ==========================================================================================
     * CAN module configuration and initialization:
     * ==========================================================================================
     *  - load the default CAN module configuration into the configuration structure
     *  - define the interrupt priority for both interrupt node pointers used in the example
     *  - initialize the CAN module with the modified configuration
     * ==========================================================================================
     */
    IfxMultican_Can_initModuleConfig(&g_multican.canConfig, &MODULE_CAN);

    g_multican.canConfig.nodePointer[RX_INTERRUPT_SRC_ID].priority = ISR_PRIORITY_CAN_RX;

    IfxMultican_Can_initModule(&g_multican.can, &g_multican.canConfig);

    /* ==========================================================================================
     * Common CAN node configuration and initialization:
     * ==========================================================================================
     *  - load the default CAN node configuration into the configuration structure
     * 
     *  - set CAN node in the "Loop back" mode (no external pins will be used)
     *  - enable usage of CAN Flexible Data rate (CAN FD) (NCRx.FDEN  = 1)
     * 
     *  - set the nominal baud rate (used during arbitration phase) to 500kbits
     *  - set the nominal sample point to 80% of the total nominal bit time
     *  - set the nominal resynchronisation jump width to 20% of the total nominal bit time
     *  - set the fast baud rate (used during data phase) to 2Mbits
     *  - set the fast sample point to 70% of the total nominal bit time
     *  - set the fast resynchronisation jump width to 20% of the total nominal bit time
     *  - set the transceiver delay compensation offset to 0
     * ==========================================================================================
     */
    IfxMultican_Can_Node_initConfig(&g_multican.canNodeConfig, &g_multican.can);

    g_multican.canNodeConfig.loopBackMode = TRUE;
    g_multican.canNodeConfig.flexibleDataRate = TRUE;

    g_multican.canNodeConfig.fdConfig.nominalBaudrate = 500000;
    g_multican.canNodeConfig.fdConfig.nominalSamplePoint = 8000;
    g_multican.canNodeConfig.fdConfig.nominalSynchJumpWidth = 2000;
    g_multican.canNodeConfig.fdConfig.fastBaudrate = 2000000;
    g_multican.canNodeConfig.fdConfig.fastSamplePoint = 7000;
    g_multican.canNodeConfig.fdConfig.fastSynchJumpWidth = 2000;
    g_multican.canNodeConfig.fdConfig.loopDelayOffset = 0;

    /* ==========================================================================================
     * CAN node 0 configuration and initialization:
     * ==========================================================================================
     *  - assign the node to CAN node 0
     *  - initialize the CAN node 0 with the modified configuration
     * ==========================================================================================
     */
    g_multican.canNodeConfig.nodeId = IfxMultican_NodeId_0;

    IfxMultican_Can_Node_init(&g_multican.canNode0, &g_multican.canNodeConfig);

    /* ==========================================================================================
     * CAN node 1 configuration and initialization:
     * ==========================================================================================
     *  - assign the node to CAN node 1
     *  - initialize the CAN node 1 with the modified configuration
     * ==========================================================================================
     */
    g_multican.canNodeConfig.nodeId = IfxMultican_NodeId_1;

    IfxMultican_Can_Node_init(&g_multican.canNode1, &g_multican.canNodeConfig);

    /* ================================================================================================================
     * Source standard message objects configuration and initialization:
     * ================================================================================================================
     *  - load the default CAN message object configuration into the configuration structure
     * 
     *  - define the message object as a transmit message object (common setting for all source message objects)
     *  - define acceptance of the frame with only matching IDE (common setting for all source message objects)
     * 
     *  - define the message object ID (each message object ID value should be unique)
     *  - define the CAN message ID used during arbitration phase 
     *  - define the standard or extended frame to be used
     *  - define the message object that holds data bytes 8 to 35 (top message)
     *  - define the message object that holds data bytes 36 to 63 (bottom message)
     * 
     *  - define the length of the transmitted data (related to MOFCRn.DLC, MOFCRn.FDF, MOFGPR.BOT, and MOFGPR.TOP bitfields)
     *  - define the usage of bit rate switching (related to MOFCRn.BRS bitfield)
     *  
     *  - initialize the source standard CAN message object with the modified configuration
     * ----------------------------------------------------------------------------------------------------------------
     * These CAN message objects are assigned to CAN Node 0
     * ================================================================================================================
     */
    IfxMultican_Can_MsgObj_initConfig(&g_multican.canMsgObjConfig, &g_multican.canNode0);

    g_multican.canMsgObjConfig.frame = IfxMultican_Frame_transmit;
    g_multican.canMsgObjConfig.control.matchingId = TRUE;

    for(currentCanMessageObject = 0; currentCanMessageObject < NUMBER_OF_CAN_FD_CASES; currentCanMessageObject++)
    {
        g_multican.canMsgObjConfig.msgObjId = (IfxMultican_MsgObjId)currentCanMessageObject;
        g_multican.canMsgObjConfig.messageId = g_messageObjectConf[currentCanMessageObject].messageId;
        g_multican.canMsgObjConfig.control.extendedFrame = g_messageObjectConf[currentCanMessageObject].extendedFrame;
        g_multican.canMsgObjConfig.control.topMsgObjId = (2 * currentCanMessageObject) + SRC_EXTENDED_MO_OFFSET; 
        g_multican.canMsgObjConfig.control.bottomMsgObjId = g_multican.canMsgObjConfig.control.topMsgObjId + 1;

        g_multican.canMsgObjConfig.control.messageLen = g_messageObjectConf[currentCanMessageObject].messageLen;
        g_multican.canMsgObjConfig.control.fastBitRate = g_messageObjectConf[currentCanMessageObject].fastBitRate;

        IfxMultican_Can_MsgObj_init(&g_multican.canSrcMsgObj[currentCanMessageObject], &g_multican.canMsgObjConfig);
    }

    /* ================================================================================================================
     * Destination standard message objects configuration and initialization:
     * ================================================================================================================
     *  - load the default CAN message object configuration into the configuration structure
     * 
     *  - define the message object as a receive message object (common setting for all destination message objects)
     *  - define acceptance of the frame with only matching IDE (common setting for all destination message objects)
     *  - enable interrupt generation in case of CAN message reception (common setting for all destination message objects)
     *  - define interrupt node pointer to be used (all destination message objects share the SAME node)
     *
     *  - define the message object ID (each message object ID value should be unique)
     *  - define the CAN message ID used during arbitration phase (should match the source message objects ID)
     *  - define the standard or extended frame to be used
     *  - define the message object that holds data bytes 8 to 35 (top message)
     *  - define the message object that holds data bytes 36 to 63 (bottom message)
     * 
     *  - define the length of the received data (related to MOFGPR.BOT and MOFGPR.TOP bitfields)
     *  
     *  - initialize the source standard CAN message object with the modified configuration
     * ----------------------------------------------------------------------------------------------------------------
     * These CAN message objects are assigned to CAN Node 1
     * ================================================================================================================
     */
    IfxMultican_Can_MsgObj_initConfig(&g_multican.canMsgObjConfig, &g_multican.canNode1);

    g_multican.canMsgObjConfig.frame = IfxMultican_Frame_receive;
    g_multican.canMsgObjConfig.control.matchingId = TRUE;
    g_multican.canMsgObjConfig.rxInterrupt.enabled = TRUE;
    g_multican.canMsgObjConfig.rxInterrupt.srcId = RX_INTERRUPT_SRC_ID;

    for(currentCanMessageObject = 0; currentCanMessageObject < NUMBER_OF_CAN_FD_CASES; currentCanMessageObject++)
    {
        g_multican.canMsgObjConfig.msgObjId = (IfxMultican_MsgObjId)(currentCanMessageObject + DST_MO_OFFSET);
        g_multican.canMsgObjConfig.messageId = g_messageObjectConf[currentCanMessageObject].messageId;
        g_multican.canMsgObjConfig.control.extendedFrame = g_messageObjectConf[currentCanMessageObject].extendedFrame;
        g_multican.canMsgObjConfig.control.topMsgObjId = (2 * currentCanMessageObject) + DST_EXTENDED_MO_OFFSET; 
        g_multican.canMsgObjConfig.control.bottomMsgObjId = g_multican.canMsgObjConfig.control.topMsgObjId + 1;

        g_multican.canMsgObjConfig.control.messageLen = g_messageObjectConf[currentCanMessageObject].messageLen;

        IfxMultican_Can_MsgObj_init(&g_multican.canDstMsgObj[currentCanMessageObject], &g_multican.canMsgObjConfig);
    }
}

/* Function to initialize and transmit CAN message.
 * Before a CAN message is transmitted, two CAN messages (TX and RX) need to be initialized.
 * The TX message (message that is transmitted) is initialized with the combination of current data payload byte and
 * current CAN message value. The RX message (message where the received CAN message is stored) is initialized with
 * invalid ID, data, length, and fast bit rate value (after successful CAN transmission the values are replaced with
 * the valid content). No additional CAN message is transmitted until the received data has been read by the interrupt
 * service routine.
 */
void transmitCanMessage(void)
{
    uint8 currentDataPayloadByte;

    /* Invalidation of the RX message */
    IfxMultican_Message_longFrameInit(&g_multican.rxMsg,
                                      INVALID_ID_VALUE,
                                      INVALID_LENGTH_VALUE,
                                      INVALID_FAST_BITRATE_VALUE);
    
    /* Invalidation of the RX message data content */
    memset((void *)(&g_multican.rxData[0]), INVALID_RX_DATA_VALUE, MAXIMUM_CAN_FD_DATA_PAYLOAD);

    /* Invalidation of the TX message data content */
    memset((void *)(&g_multican.txData[0]), INVALID_TX_DATA_VALUE, MAXIMUM_CAN_FD_DATA_PAYLOAD);
    
    /* Initialization of the TX message data content */
    for(currentDataPayloadByte = 0; 
        currentDataPayloadByte < g_dlcLookUpTable[g_messageObjectConf[g_currentCanFdUseCase].messageLen];
        currentDataPayloadByte++)
    {
        /* Each CAN message data payload byte is initialized in the following format:
         *  
         *            7           6           5           4           3           2           1           0
         *      | g_currentCanFdUseCase |                        currentDataPayloadByte                         |
         *      |       ( 0 - 3 )       |                               ( 0 - 63 )                              |
         */
        g_multican.txData[currentDataPayloadByte] = (g_currentCanFdUseCase << TX_DATA_INIT_SHIFT_OFFSET) |
                                                    currentDataPayloadByte;
    }

    if(g_messageObjectConf[g_currentCanFdUseCase].messageLen > IfxMultican_DataLengthCode_8)
    {
        /* Initialization of the TX message (long frame) */
        IfxMultican_Message_longFrameInit(&g_multican.txMsg,
                                          g_messageObjectConf[g_currentCanFdUseCase].messageId,
                                          g_messageObjectConf[g_currentCanFdUseCase].messageLen,
                                          g_messageObjectConf[g_currentCanFdUseCase].fastBitRate);

        /* Send the CAN message with the previously defined TX message content */
        while(IfxMultican_Status_notSentBusy ==
                IfxMultican_Can_MsgObj_sendLongFrame(&g_multican.canSrcMsgObj[g_currentCanFdUseCase],
                                                     &g_multican.txMsg,
                                                     (uint32*)&g_multican.txData));
        {
        }
    }
    else
    {
        /* Initialization of the TX message (standard frame) */
        IfxMultican_Message_init(&g_multican.txMsg,
                                 g_messageObjectConf[g_currentCanFdUseCase].messageId,
                                 *(uint32*)&g_multican.txData[0],
                                 *(uint32*)&g_multican.txData[4],
                                 g_messageObjectConf[g_currentCanFdUseCase].messageLen);

        /* Send the CAN message with the previously defined TX message content */
        while(IfxMultican_Status_notSentBusy ==
                IfxMultican_Can_MsgObj_sendMessage(&g_multican.canSrcMsgObj[g_currentCanFdUseCase],
                                                   &g_multican.txMsg));
        {
        }
    }

    /* Wait until previously transmitted data has been received in the destination message object */
    while(g_isrRxCount == g_currentCanFdUseCase)
    {
    }
}

/* Function to verify CAN message.
 * After each message has been received, several checks are performed:
 *     - message ID check
 *     - message length check
 *     - fast bit rate bit value
 *     - data check (expected valid data and unchanged invalid data)
 */
void verifyCanMessage(void)
{
    uint8 currentDataPayloadByte;

    /* Check if the received message ID does NOT match with the expected message ID.
     * If this is the case, an error should be reported.
     */
    if(g_multican.rxMsg.id != g_multican.txMsg.id)
    {
        g_status = CanCommunicationStatus_Error_notExpectedMessageId;
    }

    /* Check if the received message length does NOT match with the expected message length.
     * If this is the case, an error should be reported.
     */
    if(g_multican.rxMsg.lengthCode != g_multican.txMsg.lengthCode)
    {
        g_status = CanCommunicationStatus_Error_notExpectedLengthCode;
    }

    /* Check if the received fast bit rate bit does NOT match with the expected fast bit rate value.
     * If this is the case, an error should be reported.
     */
    if(g_multican.rxMsg.fastBitRate != g_multican.txMsg.fastBitRate)
    {
        g_status = CanCommunicationStatus_Error_notExpectedFastBitrateValue;
    }

    /* Finally, check if the received data does NOT match with the transmitted one.
     * If this is the case, an error should be reported. 
     *
     * Both "rxData" and "txData" arrays have the size of MAXIMUM_CAN_FD_DATA_PAYLOAD (64 bytes). Additionally, both of
     * the arrays are fully initialized so the possible incorrect number of transmitted bytes can be detected.
     * For this reason, the check is performed in two steps:
     *     - First "for" loop compares the valid expected data to the received data. The "currentDataPayloadByte"
     *       iterator variable is incremented to the number of bytes defined by the "g_multican.rxMsg.lengthCode"
     *       variable and can be either 8, 32, or 64 bytes. This value equals to the number of valid expected data bytes.
     *     - Second "for" loop checks the invalid data to make sure that the content has not been changed.
     *       The "currentDataPayloadByte" iterator variable is incremented from the current value of the variable
     *       (for this reason, the initialization part of the second "for" loop is omitted) to the
     *       MAXIMUM_CAN_FD_DATA_PAYLOAD (64 bytes) value.
     */
    for(currentDataPayloadByte = 0; 
        currentDataPayloadByte < g_dlcLookUpTable[g_multican.rxMsg.lengthCode];
        currentDataPayloadByte++)
    {
        if(g_multican.rxData[currentDataPayloadByte] != g_multican.txData[currentDataPayloadByte])
        {
            g_status = CanCommunicationStatus_Error_notExpectedData;
        }
    }

    for(/*...*/;
        currentDataPayloadByte < MAXIMUM_CAN_FD_DATA_PAYLOAD;
        currentDataPayloadByte++)
    {
        if(g_multican.rxData[currentDataPayloadByte] != INVALID_RX_DATA_VALUE)
        {
            g_status = CanCommunicationStatus_Error_notExpectedData;
        }
    }
}

/* Function to initialize the port pin that is connected to the LED */
void initLed(void)
{
    /* ======================================================================
     * Configuration of the port pin connected to the LED:
     * ======================================================================
     *  - define the GPIO port
     *  - define the GPIO pin that is the connected to the LED
     *  - define the general GPIO port pin usage (no alternate function used)
     *  - define the pad driver strength
     * ======================================================================
     */
    g_led1.port = &MODULE_P00;
    g_led1.pinIndex = PIN5;
    g_led1.mode = IfxPort_OutputIdx_general;
    g_led1.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;

    /* Initialize the port pin connected to the LED to level "HIGH"; this keeps the LED turned off as default state */
    IfxPort_setPinHigh(g_led1.port, g_led1.pinIndex);

    /* Set the port pin to output push pull mode */
    IfxPort_setPinModeOutput(g_led1.port, g_led1.pinIndex, IfxPort_OutputMode_pushPull, g_led1.mode);

    /* Set the pad driver mode */
    IfxPort_setPinPadDriver(g_led1.port, g_led1.pinIndex, g_led1.padDriver);
}
